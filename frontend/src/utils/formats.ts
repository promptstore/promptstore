export const PARA_DELIM = '\n\n';

interface CitationSource {
  start_index?: number;  // Start of segment of the response that is attributed to this source. Index indicates the start of the segment, measured in bytes.
  end_index?: number;  // End of the attributed segment, exclusive.
  uri?: string;  // URI that is attributed as a source for a portion of the text.
  license_?: string;  // License for the GitHub project that is attributed as a source for segment.  License info is required for code citations.
}

interface CitationMetadata {
  citation_sources: CitationSource[];
}

interface ContextChunk {
  content: string;
  author?: string;
  citation_metadata?: CitationMetadata;
}

interface AdditionalContext {
  content?: string;
  chunks?: ContextChunk[];
}

interface ChatRequestContext {
  system_prompt?: string;
  additional_context?: AdditionalContext;
}

enum MessageRole {
  system = 'system',
  user = 'user',
  assistant = 'assistant',
  function = 'function',
}

interface Message {
  role: MessageRole;
  content: string;
  name?: string;
  function_call?: object;
  citation_metadata?: CitationMetadata;
}

interface FewShotLearningExample {
  input: Message;
  output: Message;
}

interface ChatPrompt {
  context?: ChatRequestContext;
  examples?: FewShotLearningExample[];
  history?: Message[];
  messages: Message[];
}

interface Function {
  name: string;  // The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  description?: string;  // A description of what the function does, used by the model to choose when and how to call the function.
  parameters: object;  // JSONSchema document that describes the function and arguments.
}

interface OpenAIMessage extends Message {
  role: MessageRole;  // The role of the message author. 
  content: string;  // The contents of the message. content is required for all messages, and may be null for assistant messages with function calls.
  name?: string;  // The name of the author of this message. name is required if role is function, and it should be the name of the function whose response is in the content. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
  function_call?: object;  // The name and arguments of a function that should be called, as generated by the model.
}

class OpenAIMessageImpl implements OpenAIMessage {

  role: MessageRole;
  content: string;
  name?: string;
  function_call?: object;

  constructor({ role, content, name, function_call }: any) {
    this.role = role;
    this.content = content;
    this.name = name;
    this.function_call = function_call;
  }

}

class AssistantMessage implements OpenAIMessage {

  role = MessageRole.assistant;
  content: string;
  name?: string;
  function_call?: object;

  constructor(content: string, function_call?: object, name?: string) {
    this.content = content;
    this.function_call = function_call;
    this.name = name;
  }

}

class FunctionMessage implements OpenAIMessage {

  role = MessageRole.function;
  content: string;
  name: string;

  constructor(content: string, name: string) {
    this.content = content;
    this.name = name;
  }

}

class UserMessage implements OpenAIMessage {

  role = MessageRole.user;
  content: string;
  name?: string;

  constructor(content: string, name?: string) {
    this.content = content;
    this.name = name;
  }

}

class SystemMessage implements OpenAIMessage {

  role = MessageRole.system;
  content: string;
  name?: string;

  constructor(content: string, name?: string) {
    this.content = content;
    this.name = name;
  }

}

export function createOpenAIMessages(prompt: ChatPrompt, functions?: Function[]) {
  const messages: OpenAIMessage[] = [];
  if (prompt.context) {
    const systemPrompt = createSystemPrompt(prompt.context, functions);
    if (systemPrompt) {
      messages.push(new SystemMessage(systemPrompt));
    }
  }
  if (prompt.examples) {
    for (const { input, output } of prompt.examples) {
      messages.push(new UserMessage(input.content));
      messages.push(new AssistantMessage(output.content));
    }
  }
  if (prompt.history) {
    for (const message of prompt.history) {
      messages.push(new OpenAIMessageImpl(message));
    }
  }
  for (const message of prompt.messages) {
    messages.push(new OpenAIMessageImpl(message));
  }
  return messages;
}

function createSystemPrompt(context: ChatRequestContext, functions?: Function[]) {
  const systemPrompt: string[] = [];
  if (context.system_prompt) {
    systemPrompt.push(context.system_prompt);
  }
  if (functions) {
    systemPrompt.push('The following tools are available:');
    for (const func of functions) {
      const tooldef: string[] = [];
      tooldef.push('Name: ' + func.name);
      if (func.description) {
        tooldef.push('Description: ' + func.description);
      }
      if (func.parameters) {
        try {
          const schema = func.parameters;
          tooldef.push('Parameters: ' + schema);
        } catch (err) {
          console.error(err);
          // skip
        }
      }
      systemPrompt.push(tooldef.join('\n'));
    }
  }
  if (context.additional_context) {
    const { content, chunks = [] } = context.additional_context;
    if (content) {
      systemPrompt.push(content);
    }
    for (const chunk of chunks) {
      let ctx = chunk.content;
      if (chunk.citation_metadata) {
        const sources = chunk.citation_metadata.citation_sources.map(s => s.uri);
        ctx += ` Sources: [${sources.join(', ')}]`;
      }
      systemPrompt.push(ctx);
    }
  }
  if (systemPrompt.length) {
    return systemPrompt.join(PARA_DELIM);
  }
  return null;
}
