import { isTruthy } from '../utils';

export default ({ app, auth, logger, services }) => {

  const { executionsService } = services;

  /**
   * @openapi
   * components:
   *   schemas:
   *     CitationSource:
   *       type: object
   *       properties:
   *         start_index:
   *           type: number
   *           description: Start of segment of the response that is attributed to this source. Index indicates the start of the segment, measured in bytes.
   *         end_index:
   *           type: number
   *           description: End of the attributed segment, exclusive.
   *         uri:
   *           type: string
   *           description: URI that is attributed as a source for a portion of the text.
   *         license_:
   *           type: string
   *           description: License for the GitHub project that is attributed as a source for segment.  License info is required for code citations.
   * 
   *     CitationMetadata:
   *       type: object
   *       required:
   *         - citation_sources
   *       properties:
   *         citation_sources:
   *           type: array
   *           items:
   *             $ref: '#/components/schemas/CitationSource'
   * 
   *     FunctionCall:
   *       type: object
   *       required:
   *         - name
   *       properties:
   *         name:
   *           type: string
   *           description: The name of the function to call.
   *         arguments:
   *           type: object
   *           description: The arguments to call the function with, as generated by the model in JSON format.
   * 
   *     Message:
   *       type: object
   *       required:
   *         - role
   *         - content
   *       properties:
   *         role:
   *           type: string
   *           enum:
   *             - system
   *             - user
   *             - assistant
   *             - function
   *           description: The message role
   *         content:
   *           type: string
   *           description: The message text
   *         name:
   *           type: string
   *           description: The name of the author of this message. name is required if role is function, and it should be the name of the function whose response is in the content.
   *         function_call:
   *           $ref: '#/components/schemas/FunctionCall'
   *           description: The function to call
   *         citation_metadata:
   *           $ref: '#/components/schemas/CitationMetadata'
   *           description: Citation metadata
   *         final:
   *           type: boolean
   *           description: Is this message final in an agent interaction
   * 
   *     FunctionExecutionRequest:
   *       type: object
   *       required:
   *         - args
   *         - workspaceId
   *       properties:
   *         args:
   *           type: object
   *           description: Function arguments
   *         extraIndexes:
   *           type: array
   *           description: List of ids of additional indexes to enrich the prompt
   *           items:
   *             type: integer
   *         params:
   *           type: object
   *           description: The model parameters
   *         history:
   *           type: array
   *           description: The message history
   *           items:
   *             $ref: '#/components/schemas/Message'
   *         workspaceId:
   *           type: integer
   *           description: The workspace id
   *       example:
   *         args: {}
   *         params: {}
   *         workspaceId: 0
   * 
   *     SafetyRating:
   *       type: object
   *       required:
   *         - category
   *         - probability
   *       properties:
   *         category:
   *           type: string
   *           description: The safety rating category
   *         probability:
   *           type: number
   *           description: The probability that the rating applies to the completion
   * 
   *     CompletionChoice:
   *       type: object
   *       required:
   *         - index
   *         - message
   *       properties:
   *         finish_reason:
   *           type: string
   *           description: The reason the model stopped generating
   *         index:
   *           type: number
   *           description: The index in the choice list
   *         message:
   *           $ref: '#/components/schemas/Message'
   *           description: The generated message
   *         safety_ratings:
   *           type: array
   *           description: Ratings for the safety of a response. There is at most one rating per category.
   *           items:
   *             $ref: '#/components/schemas/SafetyRating'
   *         logprobs:
   *           type: object
   *           description: The log probabilities of the chosen tokens
   * 
   *     TokenUsage:
   *       type: object
   *       required:
   *         - completion_tokens
   *         - prompt_tokens
   *         - total_tokens
   *       properties:
   *         completion_tokens:
   *           type: number
   *           description: The number of tokens used in the response
   *         prompt_tokens:
   *           type: number
   *           description: The number of tokens used in the prompt
   *         total_tokens:
   *           type: number
   *           description: The total number of tokens used in generating a completion
   * 
   *     ContentFilter:
   *       type: object
   *       required:
   *         - reason
   *         - message
   *       properties:
   *         reason:
   *           type: number
   *           enum:
   *             - 0
   *             - 1
   *             - 2
   *           description: "The reason why generated content was blocked: BLOCKED_REASON_UNSPECIFIED = 0, SAFETY = 1, OTHER = 2"
   *         message:
   *           type: string
   *           description: The blocked message content
   * 
   *     SafetySetting:
   *       type: object
   *       required:
   *         - category
   *         - threshold
   *       properties:
   *         category:
   *           type: string
   *           description: The category for this setting.
   *         threshold:
   *           type: number
   *           enum:
   *             - 0
   *             - 1
   *             - 2
   *             - 3
   *             - 4
   *           description: "Controls the probability threshold at which harm is blocked: HARM_BLOCK_THRESHOLD_UNSPECIFIED = 0, BLOCK_LOW_AND_ABOVE = 1, BLOCK_MEDIUM_AND_ABOVE = 2, BLOCK_ONLY_HIGH = 3, BLOCK_NONE = 4."
   * 
   *     SafetyFeedback:
   *       type: object
   *       required:
   *         - rating
   *         - setting
   *       properties:
   *         rating:
   *           $ref: '#/components/schemas/SafetyRating'
   *           description: Safety rating evaluated from content.
   *         setting:
   *           $ref: '#/components/schemas/SafetySetting'
   *           description: Safety setting applied to the request.
   * 
   *     UniversalModelResponse:
   *       type: object
   *       required:
   *         - id
   *         - created
   *         - choices
   *         - n
   *       properties:
   *         id:
   *           type: string
   *           description: The response id
   *         created:
   *           type: string
   *           format: date-time
   *           description: The date-time the response was generated
   *         model:
   *           type: string
   *           description: The model key
   *         choices:
   *           type: array
   *           description: A list of generated completions
   *           items:
   *             $ref: '#/components/schemas/CompletionChoice'
   *         usage:
   *           $ref: '#/components/schemas/TokenUsage'
   *           description: Token usage stats
   *         n:
   *           type: number
   *           description: The number of requested completions for the given input
   *         filters:
   *           type: array
   *           items:
   *             $ref: '#/components/schemas/ContentFilter'
   *           description: Blocked content and reason
   *         safety_feedback:
   *           type: array
   *           items:
   *             $ref: '#/components/schemas/SafetyFeedback'
   * 
   *     ResponseMetadata:
   *       type: object
   *       properties:
   *         prompts:
   *           type: array
   *           items:
   *             $ref: '#/components/schemas/Message'
   *           description: The list of messages comprising the prompt used to generate the response
   * 
   *     FunctionResponse:
   *       type: object
   *       required:
   *         - response
   *       properties:
   *         response:
   *           $ref: '#/components/schemas/UniversalModelResponse'
   *           description: The LLM response using a universal format
   *         responseMetadata:
   *           $ref: '#/components/schemas/ResponseMetadata'
   *           description: Supplemental data to the response
   * 
   *     FunctionError:
   *       type: object
   *       required:
   *         - message
   *       properties:
   *         message:
   *           type: string
   *           description: The error message
   * 
   *     FunctionErrors:
   *       type: object
   *       required:
   *         - errors
   *       properties:
   *         errors:
   *           type: array
   *           items:
   *             $ref: '#/components/schemas/FunctionError'
   *           description: The list of errors from a failed response
   * 
   *     CompositionExecutionRequest:
   *       type: object
   *       required:
   *         - args
   *         - workspaceId
   *       properties:
   *         args:
   *           type: object
   *           description: Composition arguments
   *         params:
   *           type: object
   *           description: The model parameters
   *         workspaceId:
   *           type: integer
   *           description: The workspace id
   * 
   *     AnyValue: {}
   */

  /**
   * @openapi
   * tags:
   *   name: Executions
   *   description: The Execution API
   */

  /**
   * @openapi
   * /api/executions/{name}:
   *   post:
   *     description: Execute a semantic function.
   *     tags: [Executions]
   *     parameters:
   *       - name: name
   *         description: The function name
   *         in: path
   *         schema:
   *           type: string
   *       - name: batch
   *         description: Is this a batch request
   *         in: query
   *         schema:
   *           type: string
   *       - name: stream
   *         description: Is this a streaming request
   *         in: query
   *         schema:
   *           type: string
   *     requestBody:
   *       description: The function parameters
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/FunctionExecutionRequest'
   *     responses:
   *       200:
   *         description: The function result
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/FunctionResponse'
   *       500:
   *         description: Error
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/FunctionErrors'
   */
  app.post('/api/executions/:name', auth, async (req, res, next) => {
    const semanticFunctionName = req.params.name;
    const { username } = req.user;
    const { batch, stream } = req.query;

    // TODO
    const { args, history, params = {}, workspaceId = 1, extraIndexes } = req.body;

    const { response, responseMetadata, errors } = await executionsService.executeFunction({
      workspaceId,
      username,
      semanticFunctionName,
      args,
      history,
      params,
      extraIndexes,
      batch: isTruthy(batch),
    });
    if (errors) {
      return res.status(500).send({ errors });
    }
    if (isTruthy(stream)) {
      const headers = {
        'Content-Type': 'text/event-stream',
        'Connection': 'keep-alive',
        'Cache-Control': 'no-cache',
      };
      res.writeHead(200, headers);
      response.on('data', (data) => {
        const lines = data.toString().split('\n').filter(line => line.trim() !== '');
        for (const line of lines) {
          const message = line.replace(/^data: /, '');
          if (message === '[DONE]') {
            // Stream finished
            res.close();
          }
          try {
            const parsed = JSON.parse(message);
            res.write('data: ' + parsed.choices[0].text + '\n\n');
          } catch (error) {
            console.error('Could not JSON parse stream message', message, error);
          }
        }
      });
    } else {
      res.json({ response, responseMetadata });
    }
  });

  /**
   * @openapi
   * /api/composition-executions/{name}:
   *   post:
   *     description: Execute a composition.
   *     tags: [Executions]
   *     parameters:
   *       - name: name
   *         description: The composition name
   *         in: path
   *         schema:
   *           type: string
   *       - name: batch
   *         description: Is this a batch request
   *         in: query
   *         schema:
   *           type: string
   *     requestBody:
   *       description: The composition parameters
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/CompositionExecutionRequest'
   *     responses:
   *       200:
   *         description: The composition result
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/AnyValue'
   *       500:
   *         description: Error
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/FunctionErrors'
   */
  app.post('/api/composition-executions/:name', auth, async (req, res, next) => {
    const compositionName = req.params.name;
    const { username } = req.user;
    const batch = req.query.batch;
    // logger.debug('body:', req.body);
    const { args, params = {}, workspaceId = 1 } = req.body;

    const { response, errors } = await executionsService.executeComposition({
      workspaceId,
      username,
      compositionName,
      args,
      params,
      batch,
    });
    if (errors) {
      return res.status(500).send({ errors });
    }
    res.json(response);
  });

};
